## HalfAdder
ここで必要なのは桁上りのビットと計算した後の最下位のビットであり、真理値表と実装の説明をみればよく分かる

## FullAdder(迷った)
ここでは桁を合わせることが大事だと認識する
a+b+cを実現するんだが、これらは夫々を足し合わせると考える
a+bをした後に最上位ビット(carry)と最下位ビット(sum)が手に入る。
ここでcとsumは同じ位であるので、c+sumを実行すると、さらに最上位ビット(carry1)と最下位ビット(sum1)が手に入る

それらを実行すると、carry1とcarry2がわかるので、後は真理値表から確認して、1になるときの条件を考えるとOrゲートでくくると言う結論になる

## Adder16
ここでは、HalfAdderで最初のcarryとsumを求めて、後は順々にFullAdderで加算をし続ければOK

## increment
１つ分増えれば良いので、Addに`000000000000001`を足せば良いが、そのまま`1`を設定することは出来なかったので`true`を設定する

## ALU
zxとnxの制御ビットに従って、16ビット入力を変換する処理を最初にするのが良いとのこと
下記の通りの制御になるのでxに0を代入する、もしくは反値に変換する

### zxビット
zxが1の時に、xを0にするので、2値から適切なものを選ぶということでMuxを使う？
Muxは sel:0の時にout:aとなり、sel:1の時、out:bになる(bを0にすればよい？)

x =(Mux16:sel==zx)=> zxout 的な？

### nxビット
xの値を反転させれば良いのだから、Notゲートを通して、値を反対にした後、
Mux16ゲートで条件分岐を行えば良い気がする


```
if (zx == 1) set x = 0        // 16-bit constant
if (nx == 1) set x = !x       // bitwise not
```
