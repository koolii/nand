## HalfAdder
ここで必要なのは桁上りのビットと計算した後の最下位のビットであり、真理値表と実装の説明をみればよく分かる

## FullAdder(迷った)
ここでは桁を合わせることが大事だと認識する
a+b+cを実現するんだが、これらは夫々を足し合わせると考える
a+bをした後に最上位ビット(carry)と最下位ビット(sum)が手に入る。
ここでcとsumは同じ位であるので、c+sumを実行すると、さらに最上位ビット(carry1)と最下位ビット(sum1)が手に入る

それらを実行すると、carry1とcarry2がわかるので、後は真理値表から確認して、1になるときの条件を考えるとOrゲートでくくると言う結論になる

## Adder16
ここでは、HalfAdderで最初のcarryとsumを求めて、後は順々にFullAdderで加算をし続ければOK

## increment
１つ分増えれば良いので、Addに`000000000000001`を足せば良いが、そのまま`1`を設定することは出来なかったので`true`を設定する

## ALU
zxとnxの制御ビットに従って、16ビット入力を変換する処理を最初にするのが良いとのこと
下記の通りの制御になるのでxに0を代入する、もしくは反値に変換する

### zxビット
zxが1の時に、xを0にするので、2値から適切なものを選ぶということでMuxを使う
Muxは sel:0の時にout:aとなり、sel:1の時、out:bになる(bを0にすればよい？)

なので、Muxを使った条件分岐の為に予めMuxの引数a,bを用意して置かなければならない

x =(Mux16:sel==zx)=> zxout 的な？

zyも同じ

### nxビット
xの値を反転させれば良いのだから、Notゲートを通して、値を反対にした後、
Mux16ゲートで条件分岐を行えば良い気がする

nyも同じ

### noビット(ngビット)
noビットは関係ないのだが、input/outputに設定されているピンは普通は他のゲートの処理で指定したり、数ビットを部分的に抜き出すと言う処理はできない
しかし、outを設定時に、同ゲート内であれば、数ビットを別の変数に代入することが可能

`Mux16(a=fOut, b=nfOut, sel=no, out=out, out[0..7]=outPartial1, out[8..15]=outPartial2, out[15]=highest);`

上記は実際にALUで使用しているコードだが、outと言う変数に代入する処理を`out=out`が担当している
この`out`と言う変数はこの後、参照することはエラーになってしまうので、`out`に設定している値をこのゲートないで別の変数に代入する
`out[0..7]=outPartial1`は`out`される0から7番目までのビットを`outPartial1`に代入すると言う解釈となる

また、`out[15]=highest`を使って、最終的な`out`が０以上なのかどうか判定しているが、これは２の補数を考えればすぐわかる
もしも最上位のビットが１になっているとそれはマイナス値を表しているから(今回のALUでは２の補数を表現している)

### zrビット
これは最終的な`out`が０なのかどうか判定した結果が出力されるビットだが、どうやって１６ビットの`out`が０なのかどうか判断するかというと
逆の事を考えれば良い

つまり０以外かどうかはどうやって判断するかであり、それは`out`の１６ビットのうち、少なくとも１ビットが１になっていればいい
ということでOrゲートを使って判断するが、Orゲートを使って１ビットずつ判定してくれるのはOr,Or8Wayで、Or8Wayを使うほうが楽

Or8Wayゲートで１６ビットを２分割し、８ビットの中に１が１つでも存在するかチェックする
その後、それらの出力をOrゲートで再度少なくとも１ビット存在するかチェックし、結果をzrビットに代入する
