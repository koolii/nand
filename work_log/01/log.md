問題を解く時に書いてるメモ

## Notゲート
入力値(in)は変数が1つ(値自体は0,1の2つ)でそれを、Nandで実装しなければならない
inが1の時、Nandの入力値にそのまま当てはめるとNand(1,1)は0となり、Nand(0,0)は1となる
=> Notの入力値inをそのままNandに挿入するだけで完成する

## Andゲート
入力値は2つ(変数がa,b)でa=b=1の時に結果が1になればOK
Nandは入力値が(1,1)の時のみ0を返す
=> Nandの出力値をNotゲートで反対にしてあげればAndゲートになる

## Orゲート
入力値は2つ(変数がa,b)で少なくとも１つの入力値が1なら1を返す(どちらも0の時だけ0を返す)
態々真理値表を書いて確認しながら実装したが、ド・モルガンの法則で書けば考える必要がなかった問題
```
A Or B = Not(A And B)
```

## Xorゲート
入力値は2つ(変数a,b)でa!=bの時だけ出力が0となり、それ以外では1となる

=> AorBで[0,1,1,1]、AandBで[0,0,0,1]となる
あとはこれらの共通項を抜き出すことを考えるとAandBをNotゲートを通したものに、Andゲートを通すことでXorになることがわかる

```
((A Or B) And Not((A And b)))
```

## マルチプレクサ(Multiplexor)
入力値は3つ(a, b, sel)でデータビットと呼ばれる2つの入力から1つを選択し、出力を得るために
「選択ビット」と呼ばれる入力が１つ用いて(=セレクタ)
sel=0の時に、出力がaになり、sel=1の時に、出力がbになるようにする(If sel=0 then out=a else out=b)

なので、selで条件分岐が必要になる
使えるゲートはNand,Not,And,Or,Xor
selで条件分岐と考えるから辛い？selで入力値a,b夫々を処理すると考えると分かる？

`(Not(sel) And a)` でselが0の時の挙動ができそう
`(sel And b)` でselが1の時の挙動ができそう
のこりはOrゲートで合わせて完了

## デマルチプレクサ
マルチプレクサと反対のことを行うゲートで選択ビットに従って、２つの可能な出力のどちらかに振り分けられる

入力値はinとselで、出力がa,bになるがselの値によって、inがa,bのどちらかにそのまま流れるようにする

`If sel=0 then {a=in, b=0} else {a=0, b=in}`

selがあるからまた、Notゲートを通した値とinをそれぞれ比較するようにすればいい気がする

`(Not(sel) And in) => a`
`(sel And in) => b`

これで分かるのはselで分岐をしたいのなら、Notゲートを通してそれぞれの出力値に対して処理をしてあげればOK

## Mux4Way16(マルチプレクサ選択ビット2つ)

入力がa,b,c,dの4つ存在していて、下記の通りの出力になるようにする

この場合、sel[1]で分岐になるがその前にsel[0]で(a,b)と(c,d)の一時的な出力をしておいて、最後にsel[1]部分の分岐処理をしてあげる

二段階での選択ビットの分岐ができるようになる

```
sel:00 a
sel:01 b
sel:10 c
sel:11 d
```
