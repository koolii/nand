### Bit
単純にoutされるビットをout用と入力用に別に変数化していおく

### RAM8
レジスタを8つ重ねて、それぞれに値が保持されていて、読み込み・書き込みかはloadビットで判定、場所はaddressビットで判定

入力値のaddress(3ビット)から適当なレジスタにinを流すようにするということになる
そのため3ビットを8方向に別れるような回路を経由することが必要
だからDMux8Way(in, sel[3])を使って判定を行えば良いんじゃないか？
けど、これはinが1ビットに対応しているから16ビットには対応していない
(全ての出力に対して、Muxゲートを通すとか？)

今はDMux8Way => Mux16 => Register => Mux8Way16だと全てのRegisterに通ってしまう？

ここは結構悩んだが、最終的に、
DMux8Way/Mux8Way16ゲートを使って該当するビットのレジスタ以外の入出力を完全に無視する

DMux8Wayで入力をloadにすることで、その結果をレジスタに設定すると、
書き込み・呼び出しのどちらかの結果を返すかが判明する

それをRegisterゲートのloadに当てはめて、それぞれのレジスタの正常なoutを取得する

最終的にMux8Way16ゲートでそれぞれのoutの中からaddressに基づくoutのみを抽出する

### RAM64

RAM64.hdlにも記載したが、addressは6ビット与えられていて、
最初の3ビットがRAM8の6個の内、どれを選ぶか選択する
最後の3ビットがRAM8に与えられる変数となる

### PC

```
 * if      (reset[t] == 1) out[t+1] = 0
 * else if (load[t] == 1)  out[t+1] = in[t]
 * else if (inc[t] == 1)   out[t+1] = out[t] + 1  (integer addition)
 * else                    out[t+1] = out[t]
```

上記の擬似コードのとおりに作成するのだが、4つの出力の内1つをoutに流すということで、Mux4Way16ゲートで対応出来ないだろうか?
(ただし、selが2つ必要なので、入力ビットをselとしても使用する気がする)