# Hack機械語の仕様

## 概要
16ビットのマシン
メモリマップドI/Oデバイスはスクリーン用とキーボード用の2つがある

### メモリアドレス空間
2つの異なるアドレス空間(命令メモリ=instruction-memoryとデータメモリ=data-memory)があることを知る必要がある
どちらもメモリは16ビット幅で、15ビットのアドレス空間を持つ、つまりメモリのサイズは夫々32Kとなる

CPUは命令メモリ(=read-only)に存在するプログラムだけを実行可能
プログラムの読み込みには外部の仕組みを利用

1. 必要なプログラムが既に書き込まれたROM回路を用いることによって実現(ゲーム機でカセットを入れ替えるのと同じ)

このシミュレータは、機械語プログラムが含まれるテキストファイルから命令メモリへ読み込む手段を提供している

### レジスタ
DとAと言う2つの16ビットレジスタがあることを知る必要がある
「A=D-1」や「D＝！A」等の算術演算や論理演算で用いられる
Dはデータ値だけを保持する、Aはデータレジスタとアドレスレジスタの二役を担う
つまり、命令の使われる状況に応じて、Aの中身はデータ値だったりデータメモリのアドレスだったりする

#### Aレジスタ
Aレジスタはデータメモリ(メモリ)へ直接アクセスするために利用される

Hackの命令は16ビット幅で、アドレスの指定には15ビット必要なので、命令コードとアドレスを一つの命令に押し込めることはできない
その為(=>)、Hackではメモリアクセス命令を行う場合は"M"というラベル付けされたメモリ位置を、明確に指定することなく操作しなければならない、「D=M+1」のように（ハードコーディングできない？という事？）

##### メモリにアクセス？？？
このアドレスを解決するためには、「Mが参照するメモリのワードは、現在のAレジスタの値をアドレスとするメモリワードの値である」を決まりごととする

たとえば、「D = Memory[516] - 1」の操作は

* Aレジスタに516を設定する命令を実行
* 「D=M-1」を行う命令を実行

##### 命令メモリに直接アクセス
メモリアクセスと同じく、Hackのジャンプ命令は特定のアドレスを指定することはしないが、
その代わりに、「どのようなジャンプ命令であっても、Aレジスタの値をアドレスとするメモリワードの位置へ移動する」を決まりごととする

たとえば、「goto 35」の操作は下記によって、InstructionMemory(命令メモリ)に位置する命令を次のクロックサイクルでコンピュータが取り出すことができる

* Aレジスタに35を設定する命令を実行
* gotoコマンドを実行する(この時にアドレスを指定しない)


#### `@value`記法
valueは数値も地区は数値を表すシンボルのどちらかであり、コマンドは単に特定の値をAレジスタに格納するだけ

例はP68を読む(C言語をコンパイルした後のアセンブリ？を記述してくれている)

* Hack言語はどのような命令であれ、メモリ操作はHackコマンドを2回実行する必要がある
  * 1つは操作を行いたいアドレスを指定
  * 2つは特定の命令を指定するためのコマンド
* Hack言語は基本、2つの命令から構成される（アドレス命令=A命令・計算命令=C命令）
* A/C命令は夫々バイナリもしくはシンボルによって表すことができる

### A命令(@valueは非負数の10進数表記、またはシンボル=補数なし10進数)
A命令はAレジスタに15ビットの値を設定するために用いられる
Aレジスタに値を格納できる

`@5`という命令は、`000000000000101`と等しい、5を2進数で表記した値をAレジスタに格納するということ

#### A命令の3つの用途

1. Aレジスタを用いて定数を代入する(プログラムで定数を代入はAレジスタを用いるしかない)
2. メモリ操作(Aレジスタにメモリのアドレスを設定し、その後のC命令でAレジスタで指定したメモリ位置のデータを操作)
3. 移動命令(Aレジスタに移動先のメモリアドレスを読み込み、その後のC命令=jump命令で次の命令の位置を移動させる)
