# Hack機械語の仕様

## 概要
16ビットのマシン
メモリマップドI/Oデバイスはスクリーン用とキーボード用の2つがある

### メモリアドレス空間
2つの異なるアドレス空間(命令メモリ=instruction-memoryとデータメモリ=data-memory)があることを知る必要がある
どちらもメモリは16ビット幅で、15ビットのアドレス空間を持つ、つまりメモリのサイズは夫々32Kとなる

CPUは命令メモリ(=read-only)に存在するプログラムだけを実行可能
プログラムの読み込みには外部の仕組みを利用

1. 必要なプログラムが既に書き込まれたROM回路を用いることによって実現(ゲーム機でカセットを入れ替えるのと同じ)

このシミュレータは、機械語プログラムが含まれるテキストファイルから命令メモリへ読み込む手段を提供している

## レジスタ
DとAと言う2つの16ビットレジスタがあることを知る必要がある
「A=D-1」や「D＝！A」等の算術演算や論理演算で用いられる
Dはデータ値だけを保持する、Aはデータレジスタとアドレスレジスタの二役を担う
つまり、命令の使われる状況に応じて、Aの中身はデータ値だったりデータメモリのアドレスだったりする

### Aレジスタ
Aレジスタはデータメモリ(メモリ)へ直接アクセスするために利用される

Hackの命令は16ビット幅で、アドレスの指定には15ビット必要なので、命令コードとアドレスを一つの命令に押し込めることはできない
その為(=>)、Hackではメモリアクセス命令を行う場合は"M"というラベル付けされたメモリ位置を、明確に指定することなく操作しなければならない、「D=M+1」のように（ハードコーディングできない？という事？）

#### メモリにアクセス？？？
このアドレスを解決するためには、「Mが参照するメモリのワードは、現在のAレジスタの値をアドレスとするメモリワードの値である」を決まりごととする

たとえば、「D = Memory[516] - 1」の操作は

* Aレジスタに516を設定する命令を実行
* 「D=M-1」を行う命令を実行

#### 命令メモリに直接アクセス
メモリアクセスと同じく、Hackのジャンプ命令は特定のアドレスを指定することはしないが、
その代わりに、「どのようなジャンプ命令であっても、Aレジスタの値をアドレスとするメモリワードの位置へ移動する」を決まりごととする

たとえば、「goto 35」の操作は下記によって、InstructionMemory(命令メモリ)に位置する命令を次のクロックサイクルでコンピュータが取り出すことができる

* Aレジスタに35を設定する命令を実行
* gotoコマンドを実行する(この時にアドレスを指定しない)


### `@value`記法
valueは数値も地区は数値を表すシンボルのどちらかであり、コマンドは単に特定の値をAレジスタに格納するだけ

例はP68を読む(C言語をコンパイルした後のアセンブリ？を記述してくれている)

* Hack言語はどのような命令であれ、メモリ操作はHackコマンドを2回実行する必要がある
  * 1つは操作を行いたいアドレスを指定
  * 2つは特定の命令を指定するためのコマンド
* Hack言語は基本、2つの命令から構成される（アドレス命令=A命令・計算命令=C命令）
* A/C命令は夫々バイナリもしくはシンボルによって表すことができる

### A命令(@valueは非負数の10進数表記、またはシンボル=補数なし10進数)
A命令はAレジスタに15ビットの値を設定するために用いられる
Aレジスタに値を格納できる

`@5`という命令は、`000000000000101`と等しい、5を2進数で表記した値をAレジスタに格納するということ

#### A命令の3つの用途

1. Aレジスタを用いて定数を代入する(プログラムで定数を代入はAレジスタを用いるしかない)
2. メモリ操作(Aレジスタにメモリのアドレスを設定し、その後のC命令でAレジスタで指定したメモリ位置のデータを操作)
3. 移動命令(Aレジスタに移動先のメモリアドレスを読み込み、その後のC命令=jump命令で次の命令の位置を移動させる)

### C命令(`dest=comp;jump`)
※ destもしくはjumpのどちらかは空であるかもしれない、もしdestが空ならば「＝」が省略され、jumpが空であれば、「；」が省略される

プログラミングの中心的な役割を担う(ほとんどすべての仕事がこの命令を使う)

３つの質問に応えることができ、A命令と一緒に使うことでコンピュータで行うすべての命令を実行できる

* 何を計算するか？
* 計算した結果を何処に格納するか？
* 次に何をするか？

#### 16ビットの分割(111a | c1 c2 c3 c4 | c5 c6 d1 d2 | d3 j1 j2 j3)について

`comp` 領域がALUに何を計算するかを命令し、その計算された値をを格納する場所が `dest` 領域によって指定される
`jump` 領域は移動条件を示していて、つまり、次にどのコマンドを取り出して実行するかを言っている

* 一番左のビットは1、その次の2つは使用しない
* `a` と `cX` は `comp`
* `dX` は `dest`
* `jX` は `jump`

### `comp` 領域の仕様
HackのALUは、D/A/Mレジスタ(MはMemory[A])に対して決められた関数を実行するように設計されていて、
それはcomp領域の7ビットから決定される(P71の表を確認)

### `dest` 領域の仕様
dest領域に指定された3ビットで幾つかの場所に保存される(2^3=8通りあり、P72を確認)
最初と2番目のビットは夫々、計算結果をAレジスタとDレジスタに格納するかどうかを指定
3番目のビットは計算結果をMに格納するかどうかを指定


例えば、Memory[7]の値を1だけインクリメントし、その結果をDレジスタに保存する

```
0000 0000 0000 0111    // @7 (アドレスが7のメモリレジスタを選択する)
1111 1101 1101 1000    // MD=M+1 (M+1をcompから計算し、destのDとMに値を格納する)
```

### `jump` 領域の仕様
「次に何を行なうか」ということを指定する

* 標準的に）プログラムの次の命令をフェッチし実行する
* プログラムの何処か他の場所にある命令をフェッチし実行する(この時、移動したいアドレスは、Aレジスタに設定されていることとする)

jump領域に指定された3ビットとALUの出力値で移動するかどうかが決定する(P73の表を確認)

* 1番目のビットは、ALUの計算結果の値が `負の場合` に移動することを指定
* 2番目のビットは、ALUの計算結果の値が `0の場合` に...
* 3番目のビットは、ALUの計算結果の値が `正の場合` に...

```
// logic
If Memory[3]=5 then goto 100
else goto 200

// impelmentation
@3
D=M // D=Memory[3]
@5
D=D-A // D=D-5
@100
D;JEQ // If D=0 goto 100
@200
0;JMP // Goto 200で (0;JMP)は無条件で移動するための命令、C命令は常に何らかの計算を行わなければならないから
```

### Aレジスタの衝突
Aレジスタを使うに当たって、どちらかの目的で使用することができる

* C命令において **データメモリ** の位置を指定する(これにはMを伴う)
* C命令において **命令メモリ** の位置の指定する(これはjumpを伴う)

上記から、Aレジスタを使用する場合、移動を伴うC命令(jビットが0出ない場合)においてはMを参照すべきではない


## シンボル
アセンブラのコマンドは定数もしくはシンボルを使ってメモリ位置を参照することができる
ここでは3つある

### 定義済みシンボル
RAMアドレスの特別なものについては、どのようなアセンブリプログラムからでも呼び出せる

#### 仮想レジスタ
アセンブラによるプログラミングを単純化の為、R0からR15までのシンボルがRAMアドレスの0-15を参照する

#### 定義済みポインタ
SP, LCL, ARG, THISはRAMアドレスの0-3?を参照する
なので、4つはラベルが同一のものを指す(例えばARGとR2)

#### 入出力ポインタ(I/Oポインタ)
SCREEN/KBDはスクリーンとキーボードのメモリマップにおけるベースアドレスを示す

### ラベルシンボル
ユーザが定義するシンボル、gotoコマンドの行き先のラベルとして用いられる
宣言は `(Xxx)` という形式のコマンドで宣言し、Xxxと言うシンボルが定義される
アセンブリコードのどの場所からでも、たとえ、宣言より前からでも使用可能

### 変数シンボル
ユーザが定義したシンボルの中で、アセンブリでどこにも定義がないシンボルは変数として扱われる


## 入出力操作
Hackではスクリーンとキーボードに接続可能
このデバイスは両方共に **メモリマップ** を介してコンピュータのプラットフォームと対話ができる
物理的な入出力デバイスとメモリマップは更新ループで同期される

スクリーンに結びついたメモリ領域にバイナリ値を書き込むことで、スクリーン内のピクセルを描画できる
キーボードに結びついたメモリ領域に値を読み込むと、キーボードの状態を確認できる

#### スクリーン
横512ピクセル、縦256ピクセルの白黒のスクリーン
8Kのメモリマップで表すことができ、16384(0x4000)からメモリが始まる
物理スクリーンは左上隅からスタート、行は16ビットのワードが32個連続して並んでいる

上からr番目の行で、左からc番目の列に位置するピクセルは `RAM[16384 + r * 32 + c/16]` に位置するワードの `c%16番目のビット` に対応している???(ちょっとよくわからない)

物理スクリーンのピクセルを読み書きするためには、RAM中のメモリマップに対して読み書きすれば良い
(1=黒, 0=白)

```
@SCREEN // 左上隅の16個のピクセルに対応するメモリワードをAレジスタが指す
M=1     // 最も左のピクセルを黒く塗りつぶす
```

#### キーボード
24576(0x6000)からメモリが始まる
キーが押される度に、16ビットのASCIIコードが `RAM[24576]` に現れる
キーが何も押されていない場合はコードの0になる

ASCIIコードに加えて、独自のキーボード設定がP76に記述されている

#### サンプル

```
@xxx
D=D+M // => D=D+M[xxx]

@yyy
0;JMP // => goto @yyy
```

* Dレジスタはデータ専用
* Aレジスタはデータレジスタもアドレスレジスタも兼ねる
* Hack言語ではメモリアクセス命令を行う場合、“M”というラベル付けされたメモリ位置を、
明確に指定することなく操作しなければならない(たとえば「D=M+1」のように)
このアドレスを解決 するためには、―― M が参照するメモリのワードは、
現在のAレジスタの値をアドレスとするメモリワードの値である――ということを“決まり事”とすることて
たとえば「D = Memory[516] - 1」のような操作を行いたい場合、
まずAレジスタに 516 を設定する命令を実行し、続いて「D=M-1」を行う命令を実行する
* 「goto 35」のような操作を行いたい場合、まずAレジスタに35を設定する命令を実行し、
その次にgotoコマンドを(アドレスを指定せずに)実行する。
* `@value`コマンドは単に 特定の値をAレジスタに格納するためのコマンド
* `read-asemble.md` で必ずHack機械語の書き方が分かる(必読)
