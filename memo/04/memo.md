# 機械語

* 機械語は対象とするハードウェア上で直接実行できること、ただそれだけ
* 低水準言語のプログラミングを学ぶことは、コンピュータアーキテクチャを完全に理解するためには必須のプロセス
* 機械語を理解するための最善の方法は"手を動かすこと"
* 一般的な機械語を説明するためには、3つの抽象化についてだけ考えればよい
  * プロセッサ
  * メモリ
  * レジスタ
* 機械語は仕様によって決められた形式に従い、プロセッサとレジスタを用いてメモリを操作するように設計されている

### 言語
* 一般的な、1010000110101010のような形式を理解するためには”ゲームのルール"を知らなければならない、つまりは基盤ハードウェアの命令セットという事
* バイナリコード(2値コード)は暗号めいているため、機械語は通常ニーモニックも用いて記される
* ニーモニックは記号や英単語で記され、その名前によって何を行うのか把握することができる、例えば1010という命令コードはニーモニックで表すと **ADD** となる
* バイナリで各代わりに、これら記号によるコマンドを用いてプログラムを書くことができる(アセンブリ言語・アセンブリ)

### コマンド

どのコンピュータであれ、加算／減算のような基本的な算術演算や、ビットシフトやビット単位の否定のような基本的な論理演算を実行できることが求められる

```binary
ADD R2,R1,R3  // R2 <- R1+R3
ADD R2,R1,foo // R2 <- R1+foo
AND R1,R1,R2 // R1 <- [R1とR2のビット単位And]
```


メモリアクセスを行うコマンドは2通り
* 算術演算や論理演算の場合
* メモリに対して明示的に読み込み、格納を行う場合

メモリアクセスを行うコマンドは、いくつかのアドレッシング・モードを用いるだろう
アドレッシングモードとは、要求されたメモリのワードに対して、そのアドレスを指定する方法で
コンピュータが異なれば作法なども変わるが、3つのアドレッシング・モードはほとんどサポートされている

* 直接アドレッシング
  * 直接アドレスを指定する、もしくはシンボルを用いて特定のアドレスを参照
* イミディエイトアドレッシング
  * 定数を読み込む=つまり、命令コード中に現れる値をそのまま読み込む
  * 命令中に現れる数字領域をアドレスとして扱う代わりに、その値をそのままレジスタに読み込む
  * `LOADI R1,67 // R1 <- 67`
* 間接アドレッシング
  * ハードコーディングされることはない、ポインタを扱うために使われる
  * `x=foo[j]` の機械語について、コンパイラはまずその配列データを格納するためのメモリセグメントを割り振る、そして、セグメントのベースアドレスを参照するfooという記号を作る
  * `foo[j]` のような配列要素を参照するコードだと、配列のベースアドレスから物理的にj個離れた場所にあることに注意、そのためfoo[j]に対応するアドレスはベースアドレスにjの値を加算すると計算できる

```c
x=foo[j] // というコマンドは
x=*(foo+j) // というコマンドと同義になり、アセンブリだと
```

`*n` という表記は「Memory[n]の値」ということは意味する

```
ADD r1,foo,j // R1 <- foo+j
LOAD R2,R1   // R2 <- Memory[R1]
STR R2,x     // x  <- R2
```


分岐命令には、反復、条件分岐、サブルーチン呼び出しがある
これらの命令をプログラミングで実行するためには、機械語はプログラムの指定された位置へ移動する手段を持たなければならない
アセンブリ言語では、プログラム中の位置を指定するために、シンボルが用いられる場合もある

高水準な例
```
while (R1>=0) {
  code segment 1
}
code segment 2
```

低水準な例
```
beginWhile:
  JNG R1,endWhile //R1<0ならばendWhileへ移動
  // [code segment 1]の変換コードはここ
  JMP beginWhile // beginWhileへ移動
endWhile:
  // [code segment 2]の変換コードはここ
```
