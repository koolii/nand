# ３章 順序回路

１章２章の回路は全て、組み合わせ回路と呼ばれ、入力値の組み合わせだけに寄って、関数の値が決定する
これらは状態を持つことはなく入力値によって出口が決まるだけで値を保存することが出来ない

時間が経過してもdataを記憶することの出来る記憶素子を備える必要があり、この記憶素子は順序回路から構築が出来る
記憶素子を実装するには同期・クロッキング・フィードバックループ等の技術が必要でかなり大変だが、フリップフロップでそれをブラックボックス化できる

tickの始まりからtockの終わりまでに経過した時間を周期(cycle)と呼ぶ

### フリップフロップ
ここではフリップフロップの中でもD型フリップフロップ(DFF)を扱う
DFFは１ビットのデータ入力と１ビットのデータ出力

DFFにはクロック入力があり、このクロック入力にはマスタクロックからの信号が絶えず送られる
(時間に基づく振る舞いX)を可能にする = データ入力 + クロック入力

Xは `out(t) = in(t - 1)` と言う式になる = DFFは単に一つ前のタイムユニットの入力値を出力しているだけ

### レジスタ
レジスタは伝統的なストレージの振る舞いである `out(t) = out(t - 1)` を実現する
DFFは１つ前の入力値を出力する = `out(t) = in(t - 1)`

なので、DFFの出力をそのまま自身の回路の入力値にすれば良いと考えたりもするが、それだと永遠にループになるだけでおかしいし、はじめの入力値はなんのかも分からない

だから、入力値をDFFに渡すのか、DFFの出力値をそのまま次のDFFの入力値とするのか判断する回路(Mux)が必要となる
そして、この判別についてはレジスタ回路への「読み込みビット(load bit)」に担当させることができる

e.g) 新しい値を入力にするなら、(load bit = 1)、DFF内部の値をそのままレジスタに保持させたいならば (load bit = 0) にする

多ビットのレジスタは単純に１ビットレジスタを配列形式に並べて構築することができる
多ビットレジスタを作るときには、どのくらいの大きさにするのか `幅(width)` を決める必要があり、それらは16,32,64等の数字が使われる

そのような多ビットのレジスタの持つ値は、一般的に `ワード(word)` と呼ばれる

### メモリ
レジスタを積み重ねることでRAM(Random Access Memory)ユニットを構築することができる

RAMはランダムに選ばれたワードに対して、そのワードが位置する場所に制限を受けず、書き込み・読み込みができるということになっている
=> すべてのワードは同じ時間で直接アクセスできなければならないと言う仕様

この仕様を満たすために下記を実現する必要がある

* RAMの各ワードに対して、ユニークな番号をアドレスとして割り当てる
* アドレスから物理的なメモリにアクセスするための論理ゲートを構築する

RAM は次の３つの入力を受け取る

* データ入力
* アドレス入力
* ロードビット

アドレス入力によって、現時刻において、 RAMのどのレジスタにアクセスするかを指定する

メモリ操作が読み込みの場合(load=0)
  選択されたレジスタの値が直ちに出力される
メモリ操作が書き込みの 場合(load=1)
  次のサイクルで、選択されたメモリのレジスタに値が送られる。

RAM を設計する場合、基本的なパラメータとして、幅(width)とサイズ(size) を指定する必要がある
  幅(width) 各ワードの幅であり
  サイズ(size) RAMに存在するワードの個数

### カウンタ

タイムユニットが進む毎に、`out(t) = out(t - 1) + c` となるように、ある整数の値が加算される(cは通常1が用いられる)

カウンタは重要な役割を担っていて、一般的なCPUにはプログラムカウンタが含まれている
プログラムカウンタの出力は次に実行されるプログラム演算のアドレスとして解釈される

一般的なカウンタは他にもカウンタの値をゼロにする、新しいカウンタ値を読み込む、減算する等々

### 時間
組み合わせ回路にフィードバックループ(出力を入力に持っていく？だと思う)を導入するのは
問題があり、それは時間という概念がないから出力された値をそのまま入力とすると、無限ループに陥ってしまう

DFFには時間の概念（時間遅延）があり時刻tにおいて、時刻t-1の出力が回路自身に影響を与えている

組み合わせ回路は入力値が変われば、その出力値は時間に関係なく即時に変わるが、
DFFが組み込まれていると、その出力値が変化するタイミングは、現在のクロック周期から次のクロック周期に移行した時点

だから同じクロック周期は出力に変化がないということ
ここから分かるのは、次のクロック周期の始まりにおいてのみ正しい値を出力しなければならないという事
(クロック周期の間は不安定な状態であることを許容している)


この順序回路の出力が”離散化”される性質は、思わぬ重要な結果をもたらす
ちょっと離散について調べよう

それは、コンピュータアーキテクチャ全体を同期させることができるということ
例えば、ALUに`x + y` を計算するように指示したとして、ここで、xは近くにあるレジスタに格納去れた値であり、
yは遠く離れた場所にあるレジスタの値であると仮定

様々な物理的制約により、xとyの電気信号がALUまでに到着する時間は異なることになる
しかし、ALUは組み合わせ回路だから時間という概念はない、即座に加算が求められる
そのため、ALUの出力が正しい「`x + y`」の値になる為に僅かな時間を必要とする
その時間に達するまではALUはゴミを出力していることになる

このゴミに関してどう対応するかだが、ALUの出力は順序回路を常に通過するため、考える必要がない
しなければならないのはコンピュータのクロックを作成する時、そのクロック周期の間隔を適切に決めることだけ

（具体的に行くなら、最も距離が長い回路感を移動する時間よりも少し長い時間をクロック周期とする）

これでクロック周期内の結果は気にしないが、順序回路が状態を更新＝次のクロック周期が始まるまでにALUからは正しい値を取得できることが保証される


